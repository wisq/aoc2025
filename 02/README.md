# Part 1 (`a.exs`)

I started out immediately thinking "how do I optimise this?", knowing that I could probably brute force part 1 (by just iterating every number in the range, chopping it in half, and seeing if the halves match), but part 2's tend to strongly penalise brute forcing.

So I began by taking the first half of the digits (rounded down) of the start of the range, then generating an infinite stream of invalid IDs based on that.  So e.g. if the start number was 81, I would generate an infinite stream of `[88, 99, 1010, 1111, 1212, ...]`.  Same if the number was 813, because the "halves" (rounded) are 8 and 13, so we still start at 8.  Then I just drop invalid IDs while `id < min`, take invalid IDs while `id <= max` (which turns the infinite stream into a finite list), and I've got a list of invalid IDs for each range, which I can then sum.

Well my optimised part 1 passed the example just fine, but for the real data, it gave me an answer that the site said was too low.  So I did end up just briefly making a brute-force version with the same output format, so I could diff the results of my smart version and the guaranteed-correct brute force version.  Turns out the problem was `2-16`.  Initially, my code looked at that and said "well `2` is one digit, so half of that is zero digits" and of course that failed.  So I told it to always take at least one digit.  But that's also wrong, because then the "first half" is 2, and thus the first number it tests is `22` (which misses `11`).  So I just added a special case that if the starting ID length is 1, then you ignore all existing digits and just start your stream with a literal `1` (so `[11, 22, 33, ...]`).

# Part 2 (`b.exs`)

For part 2, I came up with a list of possible `count`+`size` slices to work with based on the range.  If you've got a range of 91 to 123, you could be looking for 2x1 digit (e.g. 99) or 3x1 digit (e.g. 111).  Then you just extract the first `size` digits and use that as your starting point for more infinite-turned-finite streams of known invalid IDs, this time duplicating the number `count` times rather than just twice.  As per part 1, you drop the ones that are too low, take them until they're too high, repeat.

The key here was to use the _top_ of the range as my reference point (since in the above range, you can't just look at 91 and say "we only need to test 2x1", you also need to test 3x1), and to handle the case where the bottom of the range has too few digits.  For example, in the `2-16` case, your only possible slice is `count=2 size=1`, but once again, you need to start your series with `1` and not `2`.  So when extracting digits from the range start, if the number of digits is less than `size*count`, we just start with `1` followed by `size - 1` zeroes (since e.g. `100100100` is the lowest possible 3x3 invalid ID).
